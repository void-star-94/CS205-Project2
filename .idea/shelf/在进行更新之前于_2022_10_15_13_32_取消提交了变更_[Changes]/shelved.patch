Index: src/sources/zh_number.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// Created by zhzhzh on 2022/10/4.\r\n//\r\n#include \"zh_number.h\"\r\n#include <algorithm>\r\n#include <stdexcept>\r\n#include <complex>\r\n#include \"functions.h\"\r\n\r\n\r\nzh_number zero = {POSITIVE,\r\n                  std::vector<uint8_t>(), 0};\r\nzh_number one = {POSITIVE,\r\n                 std::vector<uint8_t>{1}, 0};\r\nzh_number negative_one = {NEGATIVE,\r\n                          std::vector<uint8_t>{1}, 0};\r\n\r\ninline bool abs_less(const zh_number &a, const zh_number &b) {\r\n    uint64_t ll = a.nums.size() + a.power, rl = b.nums.size() + b.power;\r\n    if (ll != rl)return ll <= rl;\r\n    auto it_l = a.nums.rbegin(), it_r = b.nums.rbegin();\r\n    for (; it_l != a.nums.rend() && it_r != b.nums.rend(); ++it_l, ++it_r) {\r\n        if (*it_l != *it_r) {\r\n            return *it_l < *it_r;\r\n        }\r\n    }\r\n    return it_l == a.nums.rend();\r\n}\r\n\r\nzh_number::zh_number() {\r\n    *this = zero;\r\n}\r\n\r\nzh_number::zh_number(uint64_t num, bool s, int64_t power_) : sign(s), power(power_) {\r\n    if (num == 0) {\r\n        *this = zero;\r\n    } else {\r\n        nums.reserve(precision);\r\n        while (num) {\r\n            nums.push_back(num % 10);\r\n            num /= 10;\r\n        }\r\n    }\r\n    squeeze();\r\n}\r\n\r\nstd::strong_ordering zh_number::operator<=>(const zh_number &other) const {\r\n    if (sign xor other.sign)\r\n        return sign ? std::strong_ordering::greater : std::strong_ordering::less;\r\n    uint64_t ll = nums.size() + power, rl = other.nums.size() + other.power;\r\n    if (ll != rl)return ll <=> rl;\r\n    auto &v = other.nums;\r\n    auto it_l = nums.rbegin(), it_r = v.rbegin();\r\n    for (; it_l != nums.rend() && it_r != v.rend(); ++it_l, ++it_r) {\r\n        if (*it_l != *it_r) {\r\n            return sign ? *it_l <=> *it_r : *it_r <=> *it_l;\r\n        }\r\n    }\r\n    if (it_l == nums.rend() && it_r == v.rend())\r\n        return std::strong_ordering::equal;\r\n    if (it_l == nums.rend())\r\n        return sign ? std::strong_ordering::less : std::strong_ordering::greater;\r\n    return sign ? std::strong_ordering::greater : std::strong_ordering::less;\r\n}\r\n\r\nbool zh_number::operator==(const zh_number &other) const {\r\n    if (sign xor other.sign)return false;\r\n    if ((power != other.power) || (nums.size() != other.nums.size()))return false;\r\n    auto &v = other.nums;\r\n    auto it_l = nums.begin(), it_r = v.begin();\r\n    for (; it_l != nums.end(); ++it_l, ++it_r) {\r\n        if (*it_l != *it_r) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nstd::vector<uint8_t> operator+(const std::vector<uint8_t> &a, const std::vector<uint8_t> &b) {\r\n    if (a.empty())return a;\r\n    if (b.empty())return b;\r\n    const std::vector<uint8_t> &a_ = a.size() > b.size() ? a : b;\r\n    const std::vector<uint8_t> &b_ = a.size() > b.size() ? b : a;\r\n    std::vector<uint8_t> re;\r\n    re.reserve(zh_number::precision);\r\n    uint8_t carry = 0, sum;\r\n    for (size_t i = 0; i < a_.size(); ++i) {\r\n        sum = a_[i] + carry + (i < b_.size()) * b_[i];\r\n        carry = sum > 10 ? 1 : 0;\r\n        re.push_back(carry ? sum - 10 : sum);\r\n    }\r\n    if (carry)\r\n        re.push_back(1);\r\n    return re;\r\n}\r\n\r\nstd::vector<uint8_t> operator-(const std::vector<uint8_t> &l, const std::vector<uint8_t> &s) {// l>s\r\n    if (s.empty() || l.empty())return l;\r\n    uint8_t borrow = 0, borrow_;\r\n    std::vector<uint8_t> re;\r\n    re.reserve(zh_number::precision);\r\n    for (size_t i = 0; i < l.size(); ++i) {\r\n        borrow_ = borrow;\r\n        uint8_t tmp = (i < s.size()) * s[i];\r\n        borrow = (borrow + tmp > l[i]);\r\n        re.push_back(borrow * 10 + l[i] - borrow_ - tmp);\r\n    }\r\n    if (*re.rbegin() == 0)re.erase(re.end() - 1);\r\n    return re;\r\n}\r\n\r\nstd::ostream &operator<<(std::ostream &os, const std::vector<uint8_t> &v) {\r\n    for (auto it = v.rbegin(); it != v.rend(); ++it) {/*NOLINT*/\r\n        os << int(*it);\r\n    }\r\n    return os;\r\n}\r\n\r\nzh_number zh_number::operator+(const zh_number &other_) const {\r\n    if (isZero())return other_;\r\n    if (other_.isZero())return *this;\r\n    zh_number other = other_, tmp_ = *this;\r\n    int64_t tmp = std::abs(power - other_.power);\r\n    if (power < other_.power) {\r\n        other.pad_zeros(tmp);\r\n    } else if (power > other_.power) {\r\n        tmp_.pad_zeros(tmp);\r\n    }\r\n    zh_number re;\r\n    if (tmp_.degenerate() && other.degenerate()) {\r\n        int64_t num1 = tmp_.to_int(), num2 = other.to_int();\r\n        int64_t num3 = num1 + num2;\r\n        if (num3 == 0)return zero;\r\n        re = num3 > 0 ? zh_number(num3, POSITIVE, other.power)\r\n                      : zh_number(-num3, NEGATIVE, other.power);\r\n        re.squeeze();\r\n        return re;\r\n    }\r\n\r\n    bool b = abs_less(*this, other);\r\n    re.power = tmp_.power;\r\n    if (sign xor other.sign) {\r\n        re.sign = b ? other.sign : sign;\r\n        re.nums = b ? other.nums - tmp_.nums : tmp_.nums - other.nums;\r\n        auto it = std::find_if(re.nums.rbegin(), re.nums.rend(), [](uint8_t i) { return i != 0; });\r\n        int64_t dis = std::distance(re.nums.rbegin(), it);\r\n        re.nums.erase(re.nums.begin() + int64_t(re.nums.size() - dis), re.nums.end());\r\n    } else {\r\n        re.sign = sign;\r\n        re.nums = tmp_.nums + other.nums;\r\n    }\r\n    re.squeeze();\r\n    return re;\r\n}\r\n\r\nzh_number zh_number::operator-(const zh_number &other) const {\r\n    other.sign = !other.sign;\r\n    auto re = *this + other;\r\n    other.sign = !other.sign;\r\n    return re;\r\n}\r\n\r\nsize_t next_pow2(size_t n) {\r\n    if (n == 0) {\r\n        return 0;\r\n    }\r\n    --n;\r\n    n |= n >> 1;\r\n    n |= n >> 2;\r\n    n |= n >> 4;\r\n    n |= n >> 8;\r\n    n |= n >> 16;\r\n    return ++n;\r\n}\r\n\r\nconstexpr bool is_pow2(const unsigned n) {\r\n    return n && !(n & (n - 1));\r\n}\r\n\r\nvoid fft(std::vector<std::complex<double>> &x) {/*NOLINT*/\r\n    static constexpr double pi = 3.1415926535897932384626433832795;\r\n\r\n    // in the event that an array was passed in with a non-power-of-two length.\r\n    const size_t len = x.size();\r\n\r\n    // base case\r\n    if (len == 1) {\r\n        x = std::vector<std::complex<double>>{x[0]};\r\n        return;\r\n    }\r\n\r\n    // Partition the input list into evenly-index and oddly-indexed elements.\r\n    const size_t halfLen = len / 2;\r\n\r\n    std::vector<std::complex<double>> evens;\r\n    evens.reserve(halfLen);\r\n    std::vector<std::complex<double>> odds;\r\n    odds.reserve(halfLen);\r\n\r\n    for (size_t i = 0; i < halfLen; ++i) {\r\n        // zero-pad both partitions if the input array was not at the\r\n        // required radix=2 capacity\r\n        if (i < x.size()) {\r\n            evens.push_back(x[2 * i]);\r\n            odds.push_back(x[2 * i + 1]);\r\n        } else {\r\n            evens[i] = odds[i] = std::complex<double>{0};\r\n        }\r\n    }\r\n\r\n    // TODO: Fix the recursion!\r\n    fft(evens);\r\n    fft(odds);\r\n\r\n    // combine the even and odd partitions\r\n    const auto nf = (double) len;\r\n\r\n    for (size_t k = 0; k < halfLen; ++k) {\r\n        const auto kf = (double) k;\r\n        const double w = -2.0 * kf * pi / nf;\r\n        const std::complex<double> wk{std::cos(w), std::sin(w)};\r\n\r\n        x[k] = evens[k] + (wk * odds[k]);\r\n        x[k + halfLen] = evens[k] - (wk * odds[k]);\r\n    }\r\n}\r\n\r\nvoid ifft(std::vector<std::complex<double>> &x) {\r\n    for (std::complex<double> &e: x) {\r\n        e = std::conj(e);\r\n    }\r\n\r\n    fft(x);\r\n\r\n    const auto len = static_cast<double>(x.size());\r\n\r\n    for (std::complex<double> &e: x) {\r\n        e = std::conj(e) / len;\r\n    }\r\n}\r\n\r\nstd::vector<std::complex<double>> create_fft_table(const std::vector<uint8_t> &a, const std::vector<uint8_t> &b) {\r\n    // Create a list of complex numbers with interleaved values from the two\r\n    // input numbers. The output list must have a length that's a power of 2.\r\n    size_t aLen = a.size();\r\n    size_t bLen = b.size();\r\n    // Ensure the Cooley-Tukey algorithm has its radix=2 requirement fulfilled.\r\n    // Add a few digits to the end so the algorithm has room for overflow.\r\n    size_t size = aLen + bLen;\r\n    if (!is_pow2(size)) {\r\n        size = next_pow2(size);\r\n    }\r\n    std::vector<std::complex<double>> ret;\r\n    ret.reserve(size);\r\n    for (size_t i = 0; i < size; ++i) {\r\n        // Add some zero-padding to the output list if necessary\r\n        const uint8_t aVal = i < aLen ? a[i] : 0;\r\n        const uint8_t bVal = i < bLen ? b[i] : 0;\r\n        ret.emplace_back((double) aVal, (double) bVal);\r\n    }\r\n    return ret;\r\n}\r\n\r\nvoid convolute_fft(std::vector<std::complex<double>> &fftTable) {\r\n    const size_t fftSize = fftTable.size();\r\n\r\n    // transform.\r\n    std::vector<std::complex<double>> transforms{fftTable};\r\n    fft(transforms);\r\n\r\n    // point-wise multiplication in frequency domain.\r\n    for (size_t i = 0; i < fftSize; ++i) {\r\n        // extract the individual transformed signals from the composed one.\r\n        const std::complex<double> &ti = transforms[i];\r\n        const std::complex<double> &&tc = std::conj(transforms[-i % fftSize]);\r\n\r\n        // perform convolution\r\n        const std::complex<double> x1 = ti + tc;\r\n        const std::complex<double> x2 = ti - tc;\r\n        const std::complex<double> x3 = x1 * x2;\r\n\r\n        // avoid pedantic compilers\r\n        constexpr auto rotation = double{0.25};\r\n\r\n        fftTable[i] = std::complex<double>{x3.imag(), -x3.real()} * rotation;\r\n    }\r\n}\r\n\r\nzh_number mul_strassen(const zh_number &a, const zh_number &b) {\r\n    // Default type is double. Use floats if they perform well enough.\r\n\r\n    // building a complex signal with the information of both signals.\r\n    std::vector<std::complex<double>> fftTable = create_fft_table(a.nums, b.nums);\r\n\r\n    convolute_fft(fftTable);\r\n    ifft(fftTable);\r\n\r\n    const std::vector<std::complex<double>> &inverses = fftTable;\r\n\r\n    zh_number ret;\r\n    ret.nums.reserve(inverses.size());\r\n    ret.sign = !(a.sign xor b.sign);\r\n\r\n    for (size_t i = 0, c = 0; i < inverses.size(); ++i) {\r\n        // drop imaginary part of the number\r\n        const double x = inverses[i].real();\r\n\r\n        // round to an integer\r\n        const auto ci = (uint64_t) ((double) c + std::floor(x + 0.5));\r\n\r\n        ret.nums.push_back(ci % 10);\r\n\r\n        // carry propagation\r\n        c = (ci / 10);\r\n    }\r\n\r\n    // trim trailing zeroes from the most-significant digits\r\n    size_t numZeroes = 0;\r\n\r\n    for (size_t i = ret.nums.size(); i-- > 0;) {\r\n        if (ret.nums[i]) {\r\n            break;\r\n        }\r\n        ++numZeroes;\r\n    }\r\n\r\n    ret.nums.resize(ret.nums.size() - numZeroes);\r\n    ret.power = a.power + b.power;\r\n    ret.squeeze();\r\n    return ret;\r\n}\r\n\r\nzh_number zh_number::operator*(const zh_number &other) const {\r\n    if (isZero() || other.isZero())return zero;\r\n    zh_number re;\r\n    if (*this == one || *this == negative_one) {\r\n        re = other;\r\n        re.sign = !(sign xor other.sign);\r\n        return re;\r\n    }\r\n    if (other == one || other == negative_one) {\r\n        re = *this;\r\n        re.sign = !(sign xor other.sign);\r\n        return re;\r\n    }\r\n    if (is_pow_10()) {\r\n        re.sign = !(sign xor other.sign);\r\n        re.nums = other.nums;\r\n        re.power = power + other.power;\r\n        return re;\r\n    }\r\n    if (other.is_pow_10()) {\r\n        re.sign = !(sign xor other.sign);\r\n        re.nums = nums;\r\n        re.power = power + other.power;\r\n        return re;\r\n    }\r\n    if (degenerate() && other.degenerate()) {\r\n        int64_t num1 = to_int(), num2 = other.to_int();\r\n        int64_t num3 = num1 * num2;\r\n        re = num3 > 0 ? zh_number(num3, POSITIVE, power + other.power)\r\n                      : zh_number(-num3, NEGATIVE, power + other.power);\r\n        return re;\r\n    }\r\n    return mul_strassen(*this, other);\r\n}\r\n\r\nzh_number zh_number::operator/(const zh_number &other) const {//check before use\r\n    if (isZero())return zero;\r\n    zh_number re;\r\n    if (other == one || other == negative_one) {\r\n        re = *this;\r\n        re.sign = !(sign xor other.sign);\r\n        re.squeeze();\r\n        return re;\r\n    }\r\n    if (other.is_pow_10()) {\r\n        re.nums = nums;\r\n        re.sign = !(sign xor other.sign);\r\n        re.power = power - other.power;\r\n        re.squeeze();\r\n        return re;\r\n    }\r\n    int64_t pre = int64_t(std::max({precision, nums.size() * 2, other.nums.size() * 2}));\r\n    int64_t pad = 0;\r\n    if ((nums.size() < other.nums.size()) || (nums.size() - other.nums.size() < pre)) {\r\n        pad = int64_t(pre - nums.size() + other.nums.size());\r\n    }\r\n    zh_number a, b;\r\n    a.nums = nums;\r\n    b.nums = other.nums;\r\n    a.power = pad;\r\n    re.sign = !(sign xor other.sign);\r\n    re.nums.reserve(pre);\r\n    int64_t tmp_ = 0;\r\n    for (int64_t i = 0; i < pad; ++i, ++tmp_) {\r\n        b.power = pad - tmp_;\r\n        if (b == a) {\r\n            re.nums.push_back(1);\r\n            std::reverse(re.nums.begin(), re.nums.end());\r\n            return re;\r\n        }\r\n        if (b > a) {\r\n            if (i) {\r\n                re.nums.push_back(0);\r\n                continue;\r\n            }\r\n            while (b > a) {\r\n                tmp_++;\r\n                b.power = pad - tmp_;\r\n            }\r\n        }\r\n        uint8_t tmp = 0;\r\n        while (b < a) {\r\n            a -= b;\r\n            tmp++;\r\n            a.squeeze();\r\n        }\r\n        re.nums.push_back(tmp);\r\n        if (a.isZero()) {\r\n            std::reverse(re.nums.begin(), re.nums.end());\r\n            return re;\r\n        }\r\n    }\r\n    std::reverse(re.nums.begin(), re.nums.end());\r\n    re.power = power - other.power - tmp_ + 1;\r\n    re.squeeze();\r\n    return re;\r\n}\r\n\r\nstd::pair<zh_number, zh_number> zh_number::operator%(const zh_number &other) const {//check before use\r\n    if (*this < other)return {zero, *this};\r\n    zh_number l = *this / other;\r\n    l.squeeze();\r\n    std::cout << l * other << \"\\n\";\r\n    zh_number r = (*this) - (l * other);\r\n    std::cout << r << \"\\n\";\r\n    r.squeeze();\r\n    return {l, r};\r\n}\r\n\r\nvoid zh_number::operator+=(const zh_number &other) {\r\n    if (isZero()) {\r\n        *this = other;\r\n        return;\r\n    }\r\n    if (other.isZero())return;\r\n    *this = *this + other;\r\n    squeeze();\r\n}\r\n\r\nvoid zh_number::operator-=(const zh_number &other) {\r\n    other.sign = !other.sign;\r\n    *this += other;\r\n    other.sign = !other.sign;\r\n    squeeze();\r\n}\r\n\r\nvoid zh_number::operator*=(const zh_number &other) {\r\n    if (isZero())return;\r\n    if (other.isZero()) {\r\n        *this = zero;\r\n        return;\r\n    }\r\n    *this = *this * other;\r\n    squeeze();\r\n}\r\n\r\nvoid zh_number::operator/=(const zh_number &other) {//check before use\r\n    *this = *this / other;\r\n    squeeze();\r\n}\r\n\r\nvoid zh_number::operator%=(const zh_number &other) {//check before use\r\n    *this = (*this % other).second;\r\n    squeeze();\r\n}\r\n\r\n//int64_t zh_number::to_int() {\r\n//    squeeze();\r\n//    std::stringstream ss;\r\n//    if (!sign)ss << '-';\r\n//    for (auto it = nums.rbegin(); it != nums.rend(); ++it) {/*NOLINT*/\r\n//        ss << int(*it);\r\n//    }\r\n//    for (int i = 0; i < power; ++i) {\r\n//        ss << 0;\r\n//    }\r\n//    return std::stoll(ss.str());\r\nzh_number &zh_number::operator++() {\r\n    *this += one;\r\n    squeeze();\r\n    return *this;\r\n}\r\n\r\nzh_number &zh_number::operator--() {\r\n    *this -= one;\r\n    squeeze();\r\n    return *this;\r\n}\r\n\r\n\r\nstd::ostream &operator<<(std::ostream &os, const zh_number &n) {\r\n    if (!n.sign)os << '-';\r\n    if (n.isZero()) {\r\n        if (zh_number::tag == Print_Tag::Fractional)\r\n            os << \"0.0\";\r\n        else\r\n            os << 0;\r\n        return os;\r\n    }\r\n    auto &v = n.nums;\r\n    switch (zh_number::tag) {\r\n        case Print_Tag::Scientific:\r\n            if (v.size() == 1) {\r\n                os << int(v[0]);\r\n                if (n.power != 0)\r\n                    os << 'e' << n.power;\r\n                return os;\r\n            }\r\n            os << int(*v.rbegin()) << '.';\r\n            for (auto it = v.rbegin() + 1; it != v.rend(); ++it) {\r\n                os << int(*it);\r\n            }\r\n            if (int64_t(n.power + v.size() - 1) != 0)\r\n                os << 'e' << int64_t(n.power + v.size() - 1);\r\n            break;\r\n        case Print_Tag::Fractional:\r\n            if (n.power >= 0) {\r\n                os << n.nums;\r\n                for (int64_t i = 0; i < n.power; ++i) {\r\n                    os << 0;\r\n                }\r\n                os << \".0\";\r\n            } else {\r\n                if (v.size() > -n.power) {\r\n                    uint64_t loc = v.size() + n.power, i = 0;\r\n                    for (auto it = v.rbegin(); it != v.rend(); ++it, ++i) {\r\n                        if (i == loc)os << '.';\r\n                        os << int(*it);\r\n                    }\r\n                } else {\r\n                    uint64_t l = -n.power - v.size();\r\n                    os << \"0.\";\r\n                    for (uint64_t i = 0; i < l; ++i) {\r\n                        os << 0;\r\n                    }\r\n                    os << n.nums;\r\n                }\r\n            }\r\n            break;\r\n        case Print_Tag::Decimal:\r\n            if (n.power >= 0) {\r\n                os << n.nums;\r\n                for (int64_t i = 0; i < n.power; ++i) {\r\n                    os << 0;\r\n                }\r\n            } else {\r\n                if (v.size() > -n.power) {\r\n                    uint64_t loc = v.size() + n.power, i = 0;\r\n                    for (auto it = v.rbegin(); it != v.rend(); ++it, ++i) {\r\n                        if (i == loc)return os;\r\n                        os << int(*it);\r\n                    }\r\n                } else {\r\n                    os << 0;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return os;\r\n}\r\n\r\nbool zh_number::isZero() const {\r\n    return nums.empty();\r\n}\r\n\r\nvoid zh_number::squeeze() {\r\n    if (nums.empty()) {\r\n        power = 0;\r\n        sign = POSITIVE;\r\n        return;\r\n    }\r\n    if (nums[0] != 0)return;\r\n    auto it = std::find_if(nums.begin(), nums.end(), [](uint8_t i) { return i != 0; });\r\n    if (it == nums.end()) {\r\n        *this = zero;\r\n        return;\r\n    }\r\n    int64_t dis = std::distance(nums.begin(), it);\r\n    nums.erase(nums.begin(), it);\r\n    power += dis;\r\n}\r\n\r\nvoid zh_number::pad_zeros(const int64_t count) {\r\n    if (count <= 0)return;\r\n    squeeze();\r\n    std::vector<uint8_t> tmp(count, 0);\r\n    nums.insert(nums.begin(), tmp.begin(), tmp.end());\r\n    power -= count;\r\n}\r\n\r\n/*\r\nbool zh_number::degenerate() {\r\n    squeeze();\r\n    if (power < 0)return false;\r\n    uint64_t l = nums.size() + power;\r\n    if (l > 10)return false;\r\n    if (l < 10)return true;\r\n    return *nums.rbegin() < 2;\r\n}\r\n*/\r\nbool zh_number::degenerate() const {\r\n    uint64_t l = nums.size();\r\n    if (l > 10)return false;\r\n    if (l < 10)return true;\r\n    return *nums.rbegin() < 2;\r\n}\r\n\r\n//}\r\n\r\nint64_t zh_number::to_int() const {\r\n    std::stringstream ss;\r\n    if (!sign)ss << '-';\r\n    for (auto it = nums.rbegin(); it != nums.rend(); ++it) {/*NOLINT*/\r\n        ss << int(*it);\r\n    }\r\n    return std::stoll(ss.str());\r\n}\r\n\r\nbool zh_number::is_pow_10() const {\r\n    if (nums.size() != 1)return false;\r\n    return nums[0] == 1;\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/sources/zh_number.cpp b/src/sources/zh_number.cpp
--- a/src/sources/zh_number.cpp	(revision 54e6cbd612533f5dd9a8d3c8329c1c1863b1d4df)
+++ b/src/sources/zh_number.cpp	(date 1665811929060)
@@ -5,7 +5,7 @@
 #include <algorithm>
 #include <stdexcept>
 #include <complex>
-#include "functions.h"
+//#include "functions.h"
 
 
 zh_number zero = {POSITIVE,
